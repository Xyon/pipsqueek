#!/usr/bin/perl
use strict;

use FindBin qw($Bin);
use lib "$Bin/../lib";

use Config::Light;
use Data::Dumper;

use File::Find;
use File::Spec::Functions;

use PipSqueek::Plugin;

use POE;
use POE::Component::IRC;


# version info (do not alter!)
our $VERSION = 'PipSqueek v4.0.1 - http://pipsqueek.l8nite.net/';


# get directory we should be working out of 
my $cwd = $ARGV[0] || '.';
if( ! -d $cwd ) { die "Directory does not exist: $cwd\n"; }


# global variables
our $HANDLER_REGISTRY = {};	# stores the callbacks for registered events
our $CONFIGURATION;		# stores configuration object
my $plugin;			# just a single plugin instance


# some alarm ids
my $alarm_save_id;
my $alarm_ping_id;


#{  Main program

	open( my $pidfile, '>', catfile( $cwd, '/var/pipsqueek.pid' ) ) or
		die "Unable to open PID file for writing: $!";
	print $pidfile $$;
	close( $pidfile );

	POE::Component::IRC->new( 'pipsqueek' ) or 
		die "Failed to create P::C::I object: $!";

	POE::Session->create(
		'args'	=> [],
		'heap'	=> { 'start_time' => time() },
		'inline_states' => {
			'_start'      => \&_start,
			'_stop'       => \&_stop,
			'_default'    => \&_default,

			'pipsqueek_load_userdata' => \&pipsqueek_load_userdata,
			'pipsqueek_save_userdata' => \&pipsqueek_save_userdata,

			'pipsqueek_load_modules'  => \&pipsqueek_load_modules,

			'pipsqueek_shutdown'      => \&pipsqueek_shutdown,
			'pipsqueek_connect'       => \&pipsqueek_connect,

			'pipsqueek_ping_server'   => \&pipsqueek_ping_server,
			'pipsqueek_signal'        => \&pipsqueek_signal,

			},
		'object_states' => [],	
		'options' =>  {
			#'trace' => 1,	# uncomment to make POE verbose
			},
		'package_states' => []
	) or die "Failed to initialize POE Session: $!\n";

	
	# Our session cares about the _start and _stop events from POE::Session
	# since the rest of our events will be generated by the PoCo::IRC object
	# The PoCo::IRC object is more easily thought of as a tiny IRC client -
	# We create our client, and later we will tell it what events we wish it
	# to send to our current POE session and we'll do what we want with them

	$poe_kernel->run();
	# note, that this method does not return any useful values - the rest of
	# our program logic begins in the session's _start handler

	exit;

#}  End Main


# The initialization event for our session.  The kernel has allocated and initi-
# alized our resources, and we may begin doing things.
sub _start
{
	my ($kernel,$session) = @_[KERNEL, SESSION];

	# register our signal handlers
	$kernel->sig( 'TERM', 'pipsqueek_signal' );
	$kernel->sig( 'INT',  'pipsqueek_signal' );
	$kernel->sig( 'HUP',  'pipsqueek_signal' );
	$kernel->sig( 'USR1', 'pipsqueek_signal' );

	# load configuration
	$CONFIGURATION = Config::Light->new( 
		catfile($cwd,'/etc/pipsqueek.conf') 
	);

	# create base plugin instance
	$plugin = PipSqueek::Plugin->new( $kernel, $cwd );

	# load users
	$kernel->yield( 'pipsqueek_load_userdata' );

	# tell our IRC client that we would like to receive all the events
	$kernel->post( 'pipsqueek', 'register', 'all' );

	# load modules and connect to the network
	$kernel->yield( 'pipsqueek_load_modules' );
	$kernel->yield( 'pipsqueek_connect' );

	# set an alarm to ping the server (keeps us from timing out)
	my $pingfreq = $CONFIGURATION->param('ping_server_frequency') || 180;
	$alarm_ping_id = $kernel->delay_set( 
		'pipsqueek_ping_server', $pingfreq 
	);

	# also an alarm to save configuration data
	my $savefreq = $CONFIGURATION->param('save_data_every_n_sec') || 60;
	$alarm_save_id = $kernel->delay_set(
		'pipsqueek_save_userdata', $savefreq 
	);

	return 1;
}


# Sent to our session when it's about to stop, note we cannot post new events
# to POE from this routine, since Session cleanup removes posted events
sub _stop
{
	my ($kernel,$session) = @_[KERNEL, SESSION];

#	 wargha! should we do this?  We can't post it here, which means dupcode
	&pipsqueek_free_modules($session);

	return 1;
}



# loads the users hash up
sub pipsqueek_load_userdata { $plugin->load_userdata(); }

# writes the users hash back to disk
sub pipsqueek_save_userdata
{
	my $kernel = $_[KERNEL];
	$plugin->save_userdata();

	my $savefreq = $CONFIGURATION->param('save_data_every_n_sec') || 60;
	$alarm_save_id = $kernel->delay_set(
		'pipsqueek_save_userdata', $savefreq 
	);
}


# pings the server
# added because the bot would unexpectedly time out when everything was idle
sub pipsqueek_ping_server
{
	my $kernel = $_[KERNEL];

	$kernel->post( 'pipsqueek', 'sl', 'PING ' . time() );

	# set a new alarm
	my $pingfreq = $CONFIGURATION->param('ping_server_frequency') || 180;
	$alarm_ping_id = $kernel->delay_set( 
		'pipsqueek_ping_server', $pingfreq 
	);
}


# shuts down the bot
sub pipsqueek_shutdown
{
	my ($kernel,$session) = @_[KERNEL,SESSION];

	&pipsqueek_free_modules($session);

	$plugin->save_userdata();

	exit;
}


# we'll handle SIGUSR1 to rehash the bot code (and write the user info to file)
# we'll also handle SIGHUP to do the same, but restart the bot also
sub pipsqueek_signal
{
	my ($kernel,$signal) = @_[KERNEL, ARG0];

	if( $signal eq 'USR1' ) #  write data
	{
		$kernel->sig_handled();
		$plugin->save_userdata();
		$kernel->yield( 'pipsqueek_load_modules' );
	}
	elsif( $signal eq 'HUP' ) #  write data
	{
		$kernel->sig_handled();
		$plugin->save_userdata();
		$kernel->yield( 'pipsqueek_load_modules' );
	}
	elsif( $signal eq 'TERM' )
	{
		$kernel->sig_handled();
		$kernel->yield( 'pipsqueek_shutdown' );
	}
	elsif( $signal eq 'INT' )
	{
		$kernel->sig_handled();
		$kernel->yield( 'pipsqueek_shutdown' );
	}
}


# connects the irc bot to the network
sub pipsqueek_connect
{
	my ($kernel,$session) = @_[KERNEL, SESSION];
	my $c = $CONFIGURATION;

	my $options;

	# Load up from the configuration file
	$options->{'Server'}   = $c->param('server_address');
	$options->{'Port'}     = $c->param('server_port');
	$options->{'Password'} = $c->param('server_password');
	$options->{'Nick'}     = $c->param('identity_nickname');
	$options->{'Username'} = $c->param('identity_ident');
	$options->{'Ircname'}  = $c->param('identity_gecos');

	# Set sensible defaults
	$options->{'Server'}   ||  die 'No IRC Server! Edit pipsqueek.conf';

	if( !defined $options->{'Nick'} || $options->{'Nick'} eq "" )
	{
		$options->{'Nick'} = 'PipSqueek';
		$c->param( 'identity_nickname' => 'PipSqueek' );
	}
	
	$options->{'Port'}     ||= 6667;
	$options->{'Nick'}     ||= 'PipSqueek';
	$options->{'Username'} ||= 'pips';
	$options->{'Ircname'}  ||= $VERSION;

	$options->{'Debug'} = 0; # NOTE: Change this to see client/server text

	# Fire off a connection event
	$kernel->post( 'pipsqueek', 'connect', $options );
}






# catch events that were posted but did not have a predefined handler
# this makes it easier to write and debug our event handlers
sub _default
{
#	print STDERR "\n";
#	print STDERR "Default caught an unhandled '$_[ARG0]' event.\n";
#	if( @{$_[ARG1]} ) {
#		print STDERR "The '$_[ARG0]' event was given these params:\n";
#		foreach my $param ( @{ $_[ARG1] } ) 
#		{
#			print STDERR "\t- $param\n" if defined($param);
#		}
#	}
#	print STDERR "\n";

	# we should always return false to avoid catching system signals that go
	# unhandled (otherwise, we could only send SIGKILL to this process and 
	# expect it to behave)
	return 0;
}


# this method is a supermethod to every handler object's handling routines
# it sets up appropriate objects (this hides the complexity of POE from Handler
# modules, at the cost of decreased flexibility)
sub delegate
{
#	print "\n";
	print time() . "\tEvent received: " . $_[STATE] . "\n";

	my $message;
	my @arguments;

	# call the handlers
	foreach my $meta ( @{$HANDLER_REGISTRY->{$_[STATE]}} )
	{
		my $plugin = $meta->{'obj'};
		my $method = $meta->{'sub'};

		unless( $message ) {
			$message = $plugin->parse($_[STATE], @_[ARG0 .. ARG9]);
		}

		unless( @arguments ) {
			(undef,@arguments) = split(/\s+/, $message->message());
		}

		if( $plugin->can( $method ) )
		{
			eval { $plugin->$method( $message, @arguments ); };

			if( $@ ) {
				$@ =~ s/ at.*?$//;
				$plugin->respond( $message, "ERROR: $@" );
			}
		}
		else
		{
			$plugin->respond( $message, 
				"ERROR: Object method '$method' not found in " .
				ref($plugin) 
			);
		}
	}

#	print time() . "\tEvent finished: " . $_[STATE] . "\n";
#	print "\n";

	return 1;
}


# unloads/loads all the plugins (rehash)
sub pipsqueek_load_modules
{
	my ($kernel,$session) = @_[KERNEL, SESSION];

	# reload configuration
	$CONFIGURATION = Config::Light->new( 
		catfile($cwd,'/etc/pipsqueek.conf') 
	);

	# first clear out any old handlers we have lying around
	&pipsqueek_free_modules($session);

	my $loaded = {};
	# now find any modules that need to be loaded and load them
	find({ 'wanted' => 
	sub {
		$_ =~ s|^.*/||;
		return if /^\./ or $_ !~ /\.pm$/;
		return if $File::Find::name =~ /CVS/;
		s/\.pm$//;

		$File::Find::name =~ s/bin\/..\///;

		my $module = "PipSqueek::Plugins::$_";
		return if exists $loaded->{$module};

		eval {

		delete $INC{$File::Find::name}; # unload the module
		require $File::Find::name;      # reload the module 

		# create new instance and initialize it
		my $plugin = $module->new($kernel,$cwd);
		   $plugin->plugin_initialize();
			
		$loaded->{$module} = 1;

		# cycle through available handlers and register them
		my $handlers = $plugin->plugin_handlers();

		while( my ($event,$method) = each %$handlers )
		{
			my $meta = {'obj' => $plugin, 'sub' => $method};

			my @events;
			if( $event =~ m/^multi_(.+)/ ) {
				push(@events,"private_$1", "public_$1");
			} else {
				push(@events, $event );
			}

			foreach my $event (@events)
			{
				unless( exists $HANDLER_REGISTRY->{$event} ) 
				{
					$session->register_state(
						$event, \&delegate 
					);
				}

				push( @{$HANDLER_REGISTRY->{$event}}, $meta );
			}
		} 1;

		}; # end eval

		warn "Failed to load $module: $@\n" if $@;

	}, 'no_chdir' => 1, },

	catdir( $cwd, 'lib/PipSqueek/Plugins' ),
	catdir( $Bin, '../lib/PipSqueek/Plugins' ),

	);
}


sub pipsqueek_free_modules
{
	my ($session) = @_;

	# first clear out any old handlers we have lying around
	my $tore_down = {};
	foreach my $event ( keys %$HANDLER_REGISTRY )
	{
		foreach my $meta ( @{$HANDLER_REGISTRY->{$event}} )
		{
			unless ( exists $tore_down->{ ref($meta->{'obj'}) } )
			{
				$meta->{'obj'}->plugin_teardown() 
			}

			$tore_down->{ ref($meta->{'obj'}) } = 1;
		}

		$session->register_state($event);
		delete $HANDLER_REGISTRY->{$event};
	}
}



__END__


