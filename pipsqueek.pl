#!/usr/bin/perl
use strict;
use warnings;

use FindBin qw($Bin);

use File::Copy;
use File::Find;
use File::Spec::Functions;

use POE;
use POE::Component::IRC;

use lib "$Bin";

my $cwd = $ARGV[0] || '.';
if( ! -d $cwd ) { die "Directory does not exist: $cwd\n"; }

use PipSqueek::Bot;			# Convenience functions and settings
use PipSqueek::PoCoIRCArgParser;	# Utility PoCo::IRC argument list parser
use PipSqueek::UserManager;		# Utilities for managing 'users'

# global variables
my $handler_registry = {};	# stores the callbacks for registered events

my $pipsbot;
my $eparser;
my $usermgr;


{ # Main program

	open( PIDFILE, '>', catfile( $cwd, '/data/pid' ) ) or 
		die "Unable to open PID file for writing: $!";
	print PIDFILE $$;
	close( PIDFILE );

	POE::Component::IRC->new( 'pipsqueek' ) or 
		die "Failed to create P::C::I object: $!";

	POE::Session->create(
		'args'	=> [],
		'heap'	=> { 'start_time' => time() },
		'inline_states' => {
				'_start'	=> \&_start,
				'_stop'		=> \&_stop,
				'_default'	=> \&_default,
				'keepalive'	=> \&keepalive,
			},
		'object_states' => [],	
		'options' =>  {
			#'trace' => 1,	# uncomment to make POE verbose
		},
		'package_states' => []
	) or die "Failed to initialize POE Session: $!\n";

	# Our session cares about the _start and _stop events from POE::Session
	# since the rest of our events will be generated by the PoCo::IRC object
	# The PoCo::IRC object is more easily thought of as a tiny IRC client -
	# We create our client, and later we will tell it what events we wish it
	# to send to our current POE session and we'll do what we want with them

	$poe_kernel->run();
	# note, that this method does not return any useful values - the rest of
	# our program logic begins in the session's _start handler

	exit;
}


sub _start
# The initialization event for our session.  The kernel has allocated and initi-
# alized our resources, and we may begin doing things.
{
	my ($kernel,$session) = @_[KERNEL, SESSION];

	$session->register_state( 'rehash', \&rehash );

	&rehash;

	copy(   catfile( $cwd, '/data/xml/settings.tidy.xml' ),
		catfile( $cwd, '/data/xml/settings.xml' )    );


	# initialize the bot object
	$pipsbot = new PipSqueek::Bot({
		'file'		=> catfile( $cwd, '/data/xml/settings.xml' ),
		'kernel'	=> $kernel,
		'handler_registry' => $handler_registry,
	}) or die "Failed to create Bot: $@";

	$pipsbot->param( 'runpath' => $cwd );


	# initialize our user's database
	$usermgr = new PipSqueek::UserManager({
		'file' => catfile( $cwd, '/data/xml/users.xml' )
	}) or die "Failed to create UserManager: $@";


	# initialize our PoCo::IRC argument parser
	$eparser = new PipSqueek::PoCoIRCArgParser();


	# tell our IRC client that we would like to receive all the events
	$kernel->post( 'pipsqueek', 'register', 'all' );


	# connect to the IRC server
	$pipsbot->connect();


	$_[HEAP]->{'keepalive_time'} = time() + 180;
	$kernel->alarm( 'keepalive' => $_[HEAP]->{'keepalive_time'} );

	return 1;
}


sub _stop
# Sent to our session when it's about to stop, note we cannot post new events
# to POE from this routine, since Session cleanup removes posted events
{
	my ($kernel,$session) = @_[KERNEL, SESSION];

	print "Session shutting down.\n";

	foreach my $event ( keys %$handler_registry )
	{
		$handler_registry->{$event}->{'obj'}->teardown();
		delete $handler_registry->{$event};
	} # teardown and delete all our handler objects

	$pipsbot->save();
	$usermgr->save();

	return 1;
}


sub keepalive
# pings the server every 3 minutes
# added because the bot would unexpectedly time out for unknown reasons
{
	$_[HEAP]->{'keepalive_time'} += 180;
	$_[KERNEL]->alarm( 'keepalive' => $_[HEAP]->{'keepalive_time'} );
	$_[KERNEL]->post( 'pipsqueek', 'sl', 'PING ' . time() );
}


sub _default
# catch events that were posted but did not have a predefined handler
# this makes it easier to write and debug our event handlers
{
	#print "\n";
	#print "Default caught an unhandled '$_[ARG0]' event.\n";
	#print "The '$_[ARG0]' event was given these parameters:\n";
	#print "\t- $_\n" foreach @{$_[ARG1]};
	#print "\n";

	# we should always return false to avoid catching system signals that go
	# unhandled (otherwise, we could only send SIGKILL to this process and 
	# expect it to behave)
	return 0;
}


sub delegate
# this method is a supermethod to every handler object's handling routines
# it sets up appropriate objects (this hides the complexity of POE from Handler
# modules, at the cost of decreased flexibility)
{

	#print "\n";
	#print time() . "\tEvent received: " . $_[STATE] . "\n";

	# parse the arguments
	$eparser->parse( $_[STATE], @_[ARG0 .. ARG9] );

	# call the handler
	&{$handler_registry->{$_[STATE]}->{'sub'}}($pipsbot,$eparser,$usermgr);

	#print time() . "\tEvent finished: " . $_[STATE] . "\n";
	#print "\n";

	return 1;
}


sub rehash
# loads all the handler modules and attempts to compile them and whatnot
{
	my $kernel  = $poe_kernel;
	my $session = $poe_kernel->get_active_session();

print "Loading Handlers\n";

	foreach my $event ( keys %$handler_registry )
	{
		$handler_registry->{$event}->{'obj'}->teardown();
		$session->register_state($event);
		delete $handler_registry->{$event};
	}

	find({ 'wanted' => sub
		{
			$File::Find::name =~ m/Handlers\/(.*?)\/(.*?)\.pm$/;
			my $type = $1; # the handler type
			my $name = $2; # the module filename

			return unless defined($name);
			return if $name =~ /^\./; # no files that start with .
			return if $File::Find::name =~ /CVS/; # or CVS files

			my $module = $File::Find::name;
			$module =~ s/.*?(Handlers.*?)\.pm$/$1/;
			$module =~ s/\//::/g;

			eval # try to load the module
			{
				delete $INC{$File::Find::name};
				require $File::Find::name;
				my $obj = new $module ($cwd);
				my $handlers = $obj->get_handlers();
					
				foreach my $event ( keys %$handlers ) 
				{
					$handler_registry->{$event} = {
						'obj' => $obj,
						'sub' => $handlers->{$event}
					};

					$session->register_state(
						$event, \&delegate 
					);
				} 1;
			};

			warn "Failed to load $module: $@\n" if $@;

		}, 'no_chdir' => 1, },

		catdir( $cwd, 'Handlers' ),
		catdir( $Bin, 'Handlers' ),
	);
}


