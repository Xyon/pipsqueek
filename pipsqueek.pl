#!/usr/bin/perl

# useful pragmas
use strict;
use warnings;
use lib '.';

# modules we use
use POE;					# The Perl Object Environment
use POE::Component::IRC;	# Makes writing IRC clients less complex
use File::Find;				# Traverse a directory, call subroutine for each file found
use PipSqueek::Bot;			# Convenience functions and settings
use PipSqueek::PoCoIRCArgParser;	# Utility PoCo::IRC argument list parser
use PipSqueek::UserManager;		# Utilities for managing 'users'

# global variables
my $handler_registry = {};	# stores the callbacks for registered events

my $pipsbot;
my $eparser;
my $usermgr;

# program entry point
MAIN:
{
	POE::Component::IRC->new( 'pipsqueek' ) or die "Failed to create PoCo::IRC object: $!\n";
	POE::Session->create(
		'args'	=> [],
		'heap'	=> { 'start_time' => time() },
		'inline_states' => {
				'_start'	=> \&_start, 
				'_stop'		=> \&_stop, 
				'_default'	=> \&_default,
				'keepalive'	=> \&keepalive,
			},
		'object_states' => [],	# $object => { 'event_1' => 'event_handler_name' }
		'options' =>  { 
			#'trace' => 1,	# uncomment to make POE verbose
		},
		'package_states' => []
	) or die "Failed to initialize POE Session: $!\n";
	# Our session only cares about the _start and _stop events from POE::Session
	# since the rest of our events will be generated by the PoCo::IRC object
	# The PoCo::IRC object is more easily thought of as a tiny IRC client -
	# We create our client, and later we will tell it what events we wish it
	# to send to our current POE session, and we'll do what we want with them

	$poe_kernel->run();
	# note, that this method does not return any useful values - the rest of
	# our program logic begins in the session's _start handler

	exit;
}


sub _start
# The initialization event for our session.  The kernel has allocated and initialized
# our resources, and we may begin doing things.
{
	my ($kernel,$session) = @_[KERNEL, SESSION];
	
	find({
		'wanted' => 
			sub {
				$File::Find::name =~ m/Handlers\/(.*?)\/(.*?)\.pm$/;
				my $type = $1; # the handler type (admin,public,private,irc)
				my $name = $2; # the module filename
				return unless defined($name); 
				return if $name =~ /^\./; # don't include files startings with .
				return if $File::Find::name =~ /CVS/; # don't include files in CVS dirs

				my $module = $File::Find::name;
				$module =~ s/.*?(Handlers.*?)\.pm$/$1/;
				$module =~ s/\//::/g;

				eval { # try to load the module and set up it's handlers with our session
					require $File::Find::name;
					my $obj = new $module;
					my $handlers = $obj->get_handlers();
					
					foreach my $event ( keys %$handlers ) 
					{	# for each event that the handler told us he can handle
						$handler_registry->{$event} = {
							'obj' => $obj, 					# save the handler object
							'sub' => $handlers->{$event} 	# and the subroutine inside the obj to call
						};
						$session->register_state( $event, \&delegate ); 
						# tell our session to listen for this event
						#print "Loaded $module for event $event\n";
					}
					1;
				} or die "Failed to load $module\n$@\n"; # eval failed
			}, 
		'no_chdir' => 1, # some modules rely on us being in the basedir of this script
	},'Handlers/' );
	# end find

	$pipsbot = new PipSqueek::Bot({ 
		'file' => 'data/xml/settings.xml', # where to load bot settings from
		'kernel' => $kernel, # bot needs the kernel object so it can post events
		'handler_registry' => $handler_registry, # so we can get help/usage on handlers
	}) or die "Failed to create Bot";
	# initialize our bot settings

	$usermgr = new PipSqueek::UserManager({
		'file' => 'data/xml/users.xml'
	}) or die "Failed to create UserManager";
	# initialize our user's database

	$eparser = new PipSqueek::PoCoIRCArgParser();
	# initialize our PoCo::IRC argument parser

	$kernel->post( 'pipsqueek', 'register', 'all' );
	# tell our IRC client that we would like to receive all the events it can muster

	$pipsbot->connect();
	# connect to the IRC server

	$_[HEAP]->{'keepalive_time'} = time() + 180;
	$kernel->alarm( 'keepalive' => $_[HEAP]->{'keepalive_time'} );

	return 1;
}


sub _stop
# Sent to our session when it's about to stop, note that we cannot post new events
# to POE from this routine, since part of the Session cleanup is removing posted
# events.
{
	my ($kernel,$session) = @_[KERNEL, SESSION];

	print "Session shutting down.\n";

	foreach my $event ( keys %$handler_registry )
	{
		$handler_registry->{$event}->{'obj'}->teardown();
		delete $handler_registry->{$event};
	} # teardown and delete all our handler objects 
	# (I'm not sure if perl does this automagically, but better to be safe than sorry)

	$pipsbot->save();
	$usermgr->save();

	return 1;
}


sub keepalive
# pings the server every 3 minutes
# added because the bot would unexpectedly time out for unknown reasons
{
	$_[HEAP]->{'keepalive_time'} += 180;
	$_[KERNEL]->alarm( 'keepalive' => $_[HEAP]->{'keepalive_time'} );
	$_[KERNEL]->post( 'pipsqueek', 'sl', 'PING ' . time() );
}


sub _default
# catch events that were posted but did not have a predefined handler
# this makes it easier to write and debug our event handlers
{
	#print "\n";
	#print "Default caught an unhandled '$_[ARG0]' event.\n";
	#print "The '$_[ARG0]' event was given these parameters:\n";
	#print "\t- $_\n" foreach @{$_[ARG1]};
	#print "\n";

	return 0;	# we should always return false to avoid catching system signals that go unhandled
				# (otherwise, we can only send SIGKILL to this process and expect it to behave)
}


sub delegate
# this method is a supermethod to every handler object's handling routines
# it sets up appropriate objects (this hides the complexity of POE from Handler modules, at
# the cost of decreased flexibility)
{

	#print "\n";
	#print time() . "\tEvent received: " . $_[STATE] . "\n";

	$eparser->parse( $_[STATE], @_[ARG0 .. ARG9] );
	# parse the arguments

	&{ $handler_registry->{$_[STATE]}->{'sub'} }( $pipsbot, $eparser, $usermgr );
	# call the handler

	#print time() . "\tEvent finished: " . $_[STATE] . "\n";
	#print "\n";

	return 1;
}

